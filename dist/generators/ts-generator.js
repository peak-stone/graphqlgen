"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var os = require("os");
var prettier = require("prettier");
var ts = require("typescript");
var ast_1 = require("../ast");
var utils_1 = require("../utils");
function format(code, options) {
    if (options === void 0) { options = {}; }
    try {
        return prettier.format(code, __assign({}, options, { parser: 'typescript' }));
    }
    catch (e) {
        console.log("There is a syntax error in generated code, unformatted code printed, error: " + JSON.stringify(e));
        return code;
    }
}
exports.format = format;
function generate(args) {
    // TODO: Maybe move this to source helper
    var inputTypesMap = args.types
        .filter(function (type) { return type.type.isInput; })
        .reduce(function (inputTypes, type) {
        var _a;
        return __assign({}, inputTypes, (_a = {}, _a["" + type.name] = type, _a));
    }, {});
    // TODO: Type this
    var typeToInputTypeAssociation = args.types
        .filter(function (type) {
        return type.type.isObject &&
            type.fields.filter(function (field) { return field.arguments.filter(function (arg) { return arg.type.isInput; }).length > 0; }).length > 0;
    })
        .reduce(function (types, type) {
        var _a;
        return __assign({}, types, (_a = {}, _a["" + type.name] = [].concat.apply([], type.fields.map(function (field) {
            return field.arguments
                .filter(function (arg) { return arg.type.isInput; })
                .map(function (arg) { return arg.type.name; });
        })), _a));
    }, {});
    return "  " + renderHeader(args) + "\n\n  " + renderNamespaces(args, typeToInputTypeAssociation, inputTypesMap) + "\n\n  " + renderResolvers(args) + "\n\n  ";
}
exports.generate = generate;
function renderHeader(args) {
    var modelArray = Object.keys(args.modelMap).map(function (k) { return args.modelMap[k]; });
    var modelImports = modelArray
        .map(function (m) {
        return "import { " + m.modelTypeName + " } from '" + m.importPathRelativeToOutput + "'";
    })
        .join(os.EOL);
    return "\n// Code generated by github.com/prisma/graphqlgen, DO NOT EDIT.\n\nimport { GraphQLResolveInfo } from 'graphql'\n" + renderContext(args.context) + "\n" + modelImports + "\n  ";
}
function renderContext(context) {
    if (context) {
        return "import { " + getContextName(context) + " } from '" + context.contextPath + "'";
    }
    return "type " + getContextName(context) + " = any";
}
function renderNamespaces(args, typeToInputTypeAssociation, inputTypesMap) {
    return args.types
        .filter(function (type) { return type.type.isObject; })
        .map(function (type) {
        return renderNamespace(type, typeToInputTypeAssociation, inputTypesMap, args.modelMap, args.context);
    })
        .join(os.EOL);
}
function renderNamespace(type, typeToInputTypeAssociation, inputTypesMap, modelMap, context) {
    return "    export namespace " + type.name + "Resolvers {\n\n    " + renderScalarResolvers(type, modelMap) + "\n\n    " + renderInputTypeInterfaces(typeToInputTypeAssociation, inputTypesMap, type) + "\n\n    " + renderInputArgInterfaces(type, modelMap) + "\n\n    " + renderResolverFunctionInterfaces(type, modelMap, context) + "\n\n    " + renderResolverTypeInterface(type, modelMap, context) + "\n\n    " + '' + "\n  }\n  ";
}
function renderInputTypeInterfaces(typeToInputTypeAssociation, inputTypesMap, type) {
    if (!typeToInputTypeAssociation[type.name]) {
        return "";
    }
    return typeToInputTypeAssociation[type.name]
        .map(function (typeAssociation) {
        return "export interface " + inputTypesMap[typeAssociation].name + " {\n      " + inputTypesMap[typeAssociation].fields.map(function (field) { return field.name + ": " + getTypeFromGraphQLType(field.type.name); }) + "\n    }";
    })
        .join(os.EOL);
}
function renderScalarResolvers(type, modelMap) {
    var model = modelMap[type.name];
    if (model === undefined) {
        return "export const defaultResolvers = {}";
    }
    var filePath = model.absoluteFilePath;
    var interfaceNode = ast_1.findTypescriptInterfaceByName(filePath, model.modelTypeName);
    if (!interfaceNode) {
        throw new Error("No interface found for name " + model.modelTypeName);
    }
    // NOTE unfortunately using `.getChildren()` didn't work, so we had to use the `forEachChild` method
    var interfaceChildNodes = ast_1.getChildrenNodes(interfaceNode);
    return "export const defaultResolvers = {\n    " + interfaceChildNodes
        .filter(function (childNode) { return childNode.kind === ts.SyntaxKind.PropertySignature; })
        .map(function (childNode) {
        var childNodeProperty = childNode;
        var fieldName = childNodeProperty.name.text;
        var fieldOptional = !!childNodeProperty.questionToken;
        return { fieldName: fieldName, fieldOptional: fieldOptional };
    })
        .filter(function (_a) {
        var fieldName = _a.fieldName;
        return type.fields.some(function (field) { return field.name === fieldName; });
    })
        .map(function (_a) {
        var fieldName = _a.fieldName, fieldOptional = _a.fieldOptional;
        return renderScalarResolver(fieldName, fieldOptional, model.modelTypeName);
    })
        .join(os.EOL) + "\n  }";
}
function renderScalarResolver(fieldName, fieldOptional, parentTypeName) {
    var field = "parent." + fieldName;
    var fieldGetter = renderFieldGetter(field, fieldOptional);
    return fieldName + ": (parent: " + parentTypeName + ") => " + fieldGetter + ",";
}
function renderFieldGetter(fieldGetter, fieldOptional) {
    if (fieldOptional) {
        return fieldGetter + " === undefined ? null : " + fieldGetter;
    }
    return fieldGetter;
}
function renderInputArgInterfaces(type, modelMap) {
    return type.fields
        .map(function (field) { return renderInputArgInterface(field, modelMap); })
        .join(os.EOL);
}
function renderInputArgInterface(field, modelMap) {
    if (field.arguments.length === 0) {
        return '';
    }
    return "\n  export interface Args" + utils_1.upperFirst(field.name) + " {\n    " + field.arguments
        .map(function (arg) {
        return arg.name + ": " + printFieldLikeType(arg, modelMap);
    })
        .join(os.EOL) + "\n  }\n  ";
}
function renderResolverFunctionInterfaces(type, modelMap, context) {
    return type.fields
        .map(function (field) {
        return renderResolverFunctionInterface(field, type, modelMap, context);
    })
        .join(os.EOL);
}
function renderResolverFunctionInterface(field, type, modelMap, context) {
    // TODO double check parent for union/enum
    //   parent: ${getModelName(type.name, modelMap)}${
    //   type.type.isEnum || type.type.isUnion ? '' : 'Parent'
    // },
    return "\n  export type " + utils_1.upperFirst(field.name) + "Resolver = (\n    parent: " + getModelName(type.type, modelMap) + ",\n    args: " + (field.arguments.length > 0 ? "Args" + utils_1.upperFirst(field.name) : '{}') + ",\n    ctx: " + getContextName(context) + ",\n    info: GraphQLResolveInfo,\n  ) => " + printFieldLikeType(field, modelMap) + " | Promise<" + printFieldLikeType(field, modelMap) + ">\n  ";
}
function renderResolverTypeInterface(type, modelMap, context) {
    return "\n  export interface Type {\n    " + type.fields
        .map(function (field) {
        return renderResolverTypeInterfaceFunction(field, type, modelMap, context);
    })
        .join(os.EOL) + "\n  }\n  ";
}
function renderResolverTypeInterfaceFunction(field, type, modelMap, context) {
    return "\n    " + field.name + ": (\n      parent: " + getModelName(type.type, modelMap) + ",\n      args: " + (field.arguments.length > 0 ? "Args" + utils_1.upperFirst(field.name) : '{}') + ",\n      ctx: " + getContextName(context) + ",\n      info: GraphQLResolveInfo,\n    ) => " + printFieldLikeType(field, modelMap) + " | Promise<" + printFieldLikeType(field, modelMap) + ">\n  ";
}
function renderResolvers(args) {
    return "\nexport interface Resolvers {\n  " + args.types
        .filter(function (type) { return type.type.isObject; })
        .map(function (type) { return type.name + ": " + type.name + "Resolvers.Type"; })
        .join(os.EOL) + "\n}\n  ";
}
function getModelName(type, modelMap) {
    var model = modelMap[type.name];
    if (type.isEnum) {
        return type.name;
    }
    // NOTE if no model is found, return the empty type
    // It's usually assumed that every GraphQL type has a model associated
    // expect for the `Query`, `Mutation` and `Subscription` type
    if (model === undefined) {
        return '{}';
    }
    return model.modelTypeName;
}
function printFieldLikeType(field, modelMap) {
    if (field.type.isScalar) {
        return "" + getTypeFromGraphQLType(field.type.name) + (field.type.isArray ? '[]' : '') + (!field.type.isRequired ? '| null' : '');
    }
    if (field.type.isInput) {
        return "" + field.type.name + (field.type.isArray ? '[]' : '') + (!field.type.isRequired ? '| null' : '');
    }
    return "" + getModelName(field.type, modelMap) + (field.type.isArray ? '[]' : '') + (!field.type.isRequired ? '| null' : '');
}
function getTypeFromGraphQLType(type) {
    if (type === 'Int' || type === 'Float') {
        return 'number';
    }
    if (type === 'Boolean') {
        return 'boolean';
    }
    if (type === 'String' || type === 'ID' || type === 'DateTime') {
        return 'string';
    }
    return 'string';
}
function getContextName(context) {
    if (!context) {
        return 'Context';
    }
    return context.interfaceName;
}
//# sourceMappingURL=ts-generator.js.map